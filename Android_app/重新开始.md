更改目标为制作DM辅助系统


## 项目目标

实现一个辅助DM的管理系统

## WBS

管理系统

- 逻辑处理部分    
    - 写在最前面,每个都要做
        - 在__new__(cls)中记引用次数 并且记录创建时候的ID   描述
        - 注意相对性和绝对性(相对性的可以使用ID直接复用,绝对性的不能)
        - 事件只能在停机时删除
        - 单位 属性 装备属性 行动技能需要考虑热删除
        - 由于有些东西的名称可能不存在 所以尽可能使用ID进行检索
    - 事件
        - 事件名称(事件ID)
        - ~~事件本身的被引用处理(得到以后往func list的输入)~~
        - 用一个字典去存储一个**世界状态**
        - func list
        - ~~事件结束后调取事件列中的下一个事件,继续传递func list的输入~~
        - 让行动来决定事件列
        - func list中每个func应当得到的输入
        - \*func list的触发顺序
        - func list中func的返回值能够决定event的响应
        - 判定胜负?
    - 单位
        - 名称(ID)
        - 描述
        - 区分 玩家 NPC 和 怪物 生成物体(创建者?) 是否是模板(copy)
        - 属性list来存储所有的属性class
        - 动作list来存储所有的action class
        - 装备list作为装备槽
        - 背包
    - 属性
        - 名称(ID)
        - owner(用于直接修改owner的血量等)
        - 引用计数器
        - 描述
        - 创建者
        - (事件)属性附着时
        - (事件)属性解除时
    - 装备属性
        - 名称(ID)
        - owner(用于直接修改owner的血量等)
        - 描述
        - 创建者(掉落者)
        - (事件)装备时(向xxx事件注册xxx函数)(增加被装备对象的属性)
        - (事件)取消装备时(向xxx事件注册xxx函数)(减少被装备对象的属性)
        - 卖出/销毁时
        - 行动(技能)
        - 一些其他的展示时可供查看的属性
    - 装备/解除装备事件(需要单独定义一个通用的函数)
    - 行动(技能) (DM页面的攻击便是一个行动)
        - 名称(ID)
        - owner(用于直接修改owner的血量等)
        - 事件列(在此处约束事件的先后触发顺序)
        - 启用时(注册函数)
        - 停用时(取消注册)
        - 行动创建自己的事件列
        - \*选择行动的对象(单对象 多对象 无限对象)
        - \*行动可以变为*遭遇*
        - 决定为之后层的事件列的输入
        - 创建世界类型的动态键值
    - 注册函数列
        - 名称ID
        - 引用计数器
        - 注册者ID(并非单位级别的ID而是属性级别的ID)
        - 注册时,如果按照ID注册则对应引用计数器+1
        - 如果ID在函数列中不存在则去寻找
    - 世界状态
        - 世界状态是唯一的字典(是动态字典)
        - 包括友方(list) 敌方(list) 攻击者(list) 防御者(list)
        - 用行动去规定世界状态
    - 注册状态
        - 注册状态是一个类,用于存储ID对应的对象
        - 注册状态.content 是字典用于存储ID对应的对象
        - 注册状态可以获取下一个可分配的ID
        - 注册状态可以检测一个ID是否被占用
```python
    def __new__(cls, *args, **kwargs):
        cls.__count += 1
        return object.__new__(cls)
```

## 考虑可传递性和活动社区

- 类
    - 此类之中的对象1
    - 对象2
    - 等等

**问题:如果对象嵌套对象呢?**

**问题:是否可以继续跟踪注册的内容?**

考虑使用字典方法

## 头文件

```python
class event():
    def __new__(cls,*args,**kwargs):
        #此处实现检测创建了多少个event
        return object.__new__(cls)
    def __init__(self):
        #需要处理ID(ID不可更改)
        #名称可以先没有(如果没有视作未命名)
        
    def func_list_append(self,func=None,id=None,posi=-1):
        assert func or id != None #这个函数同时支持用ID创建和用函数直接创建
        

        #此方法用于在func_list中插入函数
        #暂时不实现指定位置插入函数的概念
        self.func_list.append(func)
    
    

```